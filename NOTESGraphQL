These notes were compiled as I built my application from the ground up. My hopes are that they will be beneficial to anyone needing extra clarification and a one-stop resource on building a MERN app utiliziing Apollo and GraphQL.

GraphQL only has one endpoint
Schema + Resolvers => Server

Using a Schema Definition Language (SDL)-
You can programmatically create a schema using language constructs
SDL = more declarative
Use SDL to create schemas
parts of a schema-
types = construct defining a shape with fields
fields = keys on a type that have a name and a value type
scalars = primitive value type built into GraphQL
-String
-Int interger
-Float (decimal based numbers)
-Boolean (true or false)
-ID (String but used as a unique identifier)
query = type that defines how clients can access data
mutation = type that defines how clients can modify or create data


typeDefs
const typeDefs = gql`
type <type> {
    <field>: <scalar>!
    <field>: <scalar>
    <field>: [<type>]

}
`
example:
const typeDefs = gql`
  type User {
    _id: ID!
    username: String!
    email: String!
    pets: [Pet]
    savedPets: [Pet]
    friends: [User]
  }
  `

An ! at the end of a typeDef indicates required values (graphQL will break if these values become null)
Example: email: String! indicates that the email field will never become null

[ ] indicates the field is an array
Example: savedPets: [Pet] indicates that savedPets is an array of pets

! outside an array [<type>]! indicates that the field will always be an array
Example: friends: [User]! indicates that the field friends will always be an array of users

! within a required array [<type>!]! indicates the array will always have something in it
Example: friends: [User!]! indicates that friends will always be an array that always contains Users

Reminder- Failing to resolve the ! in resolvers will cause GraphQL to break

Queries

Schemas at a minimum require a query (Don't use a value other than Query- we don't want to confuse anyone!)
Queries have fields that resolve to values. 
Queries can take scalars as well as other types.

const typeDefs = gql`
...

type Query {
    me: User!
}
`
This is a query to view User's information. The type Query has a field called me with a value of a non-null user. The User value will contain the fields defined in the typeDefs. The ! It will use a resolver to call a function me() to fulfill the query of a user's information. The ! requires the user's information as the result of the me() function.

What is a Query?
A Query is a type on a schema that defines operations clients can perform to access data that resembles the shape of the other Types in the schema. 


Resolvers

Resolvers create the functions that fulfill the queries that have been defined. Resolvers execution is dependent on the incoming client Query. These must always be a 1-to-1 ratio with Queries. Resolver names must match the exact field name on your schema's types

const resolvers = {
    Query: {
        me() {
            return {
                username: "cossette",
                email:  "good.doggo@gmail.com",
                pets: [ ],
                savedPets: [ ],
                friends: [ ],
            }
        }
    }
}

This resolver creates the me() function that fulfills the me: User! query. This specifies that the me() function will produce the expected outcome of User. As a reminder, the type User is set to produce the following results:

    username: String!
    email: String!
    pets: [Pet]
    savedPets: [Pet]
    friends: [User]

The me() function is chained to return the data that satisfies the User type. Since username and email are required, these strings cannot be left blank. I put fake information using my programming partner Cossette as my muse.

Arguments


Other notes-
To keep my code squeeky clean I separated my resolvers and typeDefs into different files and exported them using the following code at the bottom:

module.exports = typeDefs;
module.exports = resolvers;

I then imported them to a schema index.js file using the following code:

const typeDefs = require('./typeDefs');
const resolvers = require('./resolvers');

module.exports = { typeDefs, resolvers };

My typeDefs and resolvers are then linked to the ApolloServer using the following code on my server-side server.js file

Imports the ApolloServer class
const { ApolloServer } = require('apollo-server-express');

// Import the two parts of a GraphQL schema
const { typeDefs, resolvers } = require('./schemas');
const db = require('./config/connection');

const server = new ApolloServer({
  typeDefs,
  resolvers,
  // context: authMiddleware,
  cache: 'bounded',
});

// Creates a new instance of an Apollo server with the GraphQL schema
const startApolloServer = async (typeDefs, resolvers) => {
  await server.start();
  server.applyMiddleware({ app });

  db.once('open', () => {
    app.listen(PORT, () => {
      console.log(`API Server is running on port ${PORT}!`);
      console.log(`Navigate to GraphQL at http://localhost:${PORT}${server.graphqlPath}`);
    })
  })
};

// Calls the async function to start the server
startApolloServer(typeDefs, resolvers);

Arguments
Arguments allow clients to pass variable along with Queries that can be used in your Resolvers to get data
Must be defined in schema
Can be added to any field
Either all scalars or types